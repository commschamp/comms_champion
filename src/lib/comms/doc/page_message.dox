/// @page page_message_tutorial Messages Tutorial
/// @tableofcontents
/// The communication protocols are all about exchanging @b messages over some
/// I/O link between two or more nodes. This tutorial page goes through and explains
/// every stage in defining messages for any custom communication protocol.
///
/// There are two main stages in defining the protocol messages. The first one
/// is defining the common @ref page_message_tutorial_interface class with 
/// required polymorphic behaviour. The second one is 
/// @ref page_message_tutorial_implementation of the actual messages, that
/// implement necessary virtual functions in defined polymorphic interface.
/// 
/// @section page_message_tutorial_interface Interface
/// The COMMS library provides comms::Message
/// class that must be a base class for all the custom messages that are going
/// to be implemented. It receives variable number of template parameters, which
/// are expected to be functionality extension options (defined in comms::option
/// namespace). These options define the <b>common interface</b> for all the custom
/// messages. 
///
/// Depending on the options provided to the comms::Message, it
/// can define the following public @b polymorphic interface:
/// @li comms::Message::getId() - Retrieval of the ID of the message.
/// @li comms::Message::read() - Read message data from the stream of raw bytes
/// @li comms::Message::write() - Write message data to the output buffer.
/// @li comms::Message::dispatch() - Dispatch message for handling.
/// @li comms::Message::length() - Get number of bytes required to serialise
///     the message having the current state.
/// @li comms::Message::valid() - Check the validity of the message data.
/// @li comms::Message::refresh() - Bring the message contents into a consistent 
///     state.
///
/// In general, all the API functions that are being added to the interface (and described below)
/// use <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-Virtual_Interface">Non-Virtual Interface</a>
/// idiom:
/// @code
/// class Message
/// {
/// public:
///     void someFunction(...)
///     {
///         ...; // Pre-conditions check and/or other common operations
///         someFunctionImpl(...); // Invocation of polymorphic functionality
///         ...; // Post-conditions check and/or other common operations
///     }
///
/// protected:
///     virtual void someFunctionImpl(...) = 0; // Must be implemented in the derived class
/// };
/// @endcode
/// The polymorphic behaviour is exposed via @b protected virtual functions having
/// the same name, but with @b Impl suffix.
///
/// When defining the common interface class for all the custom protocol messages
/// it is recommended to typedef the comms::Message definition with all the
/// required options:
/// @code
/// typedef comms::Message<.../* Required Options */> MyMessage;
/// @endcode
///
/// If the default interface comms::Message provides is not enough and needs to
/// be extended, then it can easily be done using public inheritance:
/// @code
/// class MyMessage : public comms::Message<...>
/// {
/// public:
///     const char* name() const
///     {
///         return nameImpl();
///     }
///
/// protected:
///     virtual const char* nameImpl() const = 0;
/// };
/// @endcode
///
/// So, let's review all the supported options one by one:
/// 
/// @subsection page_message_tutorial_interface_endian Serialisation Endian
/// Most of the messages carry some kind of payload, which needs to be
/// serialised. Usually the protocol uses the same serialisation endian (Big or Little)
/// for all the data in all the messages. When using comms::Message to
/// define interface for all the messages, it is recommended to specify
/// the serialisation endian using comms::option::BigEndian or 
/// comms::option::LittleEndian options. 
/// @code
/// typedef comms::Message<
///     ...
///     comms::option::BigEndian,
///     ...
/// > MyMessage;
/// @endcode
/// If and only if the endian specification option was used, the
/// comms::Message class defines following internal functions and types. 
/// @code
/// class MyMessage
/// {
/// public:
///     // comms::Field class with the same endian option. 
///     // Can (and should) be provided as a base class to all the
///     // fields.
///     typedef comms::Field<.../* Same endian option*/> Field;
///
/// protected:
///     // Read serialised value of type T from input buffer using proper 
///     // serialisation endian.
///     template <typename T, typename TIter>
///     static T readData(TIter& iter);
/// 
///     // Read serialised value of type T from input buffer using proper 
///     // serialisation endian with number of bytes to read specified by the
///     // template parameter TSize.
///     template <typename T, std::size_t TSize, typename TIter>
///     static T readData(TIter& iter);
///
///     // Serialise value into output buffer using proper serialisation endian.
///     template <typename T, typename TIter>
///     static void writeData(T value, TIter& iter);
///
///     // Serialise value into output buffer using proper serialisation endian
///     // with number of bytes to write specified by the template parameter TSize.
///     template <std::size_t TSize, typename T, typename TIter>
///     static void writeData(T value, TIter& iter);
/// };
/// @endcode
/// Every message interface may define read and/or write functionalities
/// (described later), which will have to be implemented in the custom
/// message class. The @b readData() and @b writeData() static member functions
/// are provided for help in this task. @n
/// Also note, the definition of the @b Field internal type. Later this tutorial
/// will present information on using @b fields to define message payload. The 
/// value of every such @b field needs to be serialised/deserialised. The comms
/// library provides multiple built-in fields that reside in comms::field
/// namespace and described in details in @ref page_field_tutorial page.
/// Almost every such field will require a variant of comms::Field class to be
/// used as the base class. It is alse expected to provide @b readData() and 
/// @b writeData() member functions which can be used to serialise stored value.
/// The internal @b Field type definition inside the
/// @b MyMessage interface class may be used as such.
///  
/// @subsection page_message_tutorial_interface_id_type Type of Message ID
/// Every message must have an ID. Most communication protocols define it
/// as a numeric value that occupies one or two bytes when serialised. The 
/// best and easiest way to define the ID type is by using @b enum with underlying
/// type specification:
/// @code
/// enum MyMsgId : std::uint8_t
/// {
///     MyMsgId_Message1,
///     MyMsgId_Message2,
///     MyMsgId_Message3,
///     ...
/// }; 
/// @endcode
/// When type, that is going to be used to store ID of the message, is defined
/// it should be passed to the definition of the interface using 
/// comms::option::MsgIdType option:
/// @code
/// typedef comms::Message<
///     ...
///     comms::option::MsgIdType<MyMsgId>,
///     ...
/// > MyMessage;
/// @endcode
/// After using such option the interface class (@b MyMessage) defines the 
/// following types:
/// @code
/// class MyMessage
/// {
/// public:
///     // Type of the ID, same as the one passed with comms::option::MsgIdType
///     typedef ... MsgIdType;
///
///     // Type of the ID, when it is passed as a parameter and/or returned from the function:
///     typedef ... MsgIdParamType;
/// }
/// @endcode
/// @b Note the existence of @b MsgIdType and @b MsgIdParamType. When the
/// type used for message ID is simple integral one or enum, these types
/// are equal.
/// However, if some other type is used, such as std::string, then @b MsgIdParamType
/// is a const-reference to @b MsgIdType.
///
/// @subsection page_message_tutorial_interface_id_retrieve Polymorphic Retrieval of Message ID
/// When there is a need to be able to polymorphically retrieve message ID,
/// the comms::option::IdInfoInterface option needs to be used in addition
/// to comms::option::MsgIdType. 
/// @code
/// typedef comms::Message<
///     ...
///     comms::option::MsgIdType<MyMsgId>,
///     comms::option::IdInfoInterface,
///     ...
/// > MyMessage;
/// @endcode
/// It adds the following functions:
/// @code
/// class MyMessage
/// {
/// public:
///     // API function to retrieve ID of the function
///     MsgIdParamType getId() const
///     {
///         return getIdImpl();
///     }
///
/// protected:
///     virtual MsgIdParamType getIdImpl() const = 0; // Must be implemented in the derived class
/// }
/// @endcode
/// The usage of comms::option::IdInfoInterface without comms::option::MsgIdType
/// will be ignored, and @b getId() as well as @b getIdImpl() member functions
/// won't be created.
///
/// @subsection page_message_tutorial_interface_read Polymorphic Read of Payload (Deserialisation)
/// If the implementation requires polymorphic read and process of input messages, the @b read()
/// operation needs to be added to the interface. It is achieved by using 
/// comms::option::ReadIterator option to provide a type of the iterator that
/// is going to be used for reading:
/// @code
/// typedef comms::Message<
///     ...
///     comms::option::ReadIterator<const std::uint8_t*>,
///     ...
/// > MyMessage;
/// @endcode
/// As the result the interface class defines the following types and functions:
/// @code
/// class MyMessage
/// {
/// public:
///     // Type of the the iterator used for reading, the same as provided with
///     // comms::option::ReadIterator option.
///     typedef ... ReadIterator;
///
///     // API function to perform read
///     comms::ErrorStatus read(ReadIterator& iter, std::size_t len)
///     {
///         return readImpl(iter, len);
///     }
///
/// protected:
///     // May be overriden in the derived class.
///     virtual comms::ErrorStatus readImpl(ReadIterator& iter, std::size_t len) 
///     {
///         return comms::ErrorStatus::NotSupported;
///     }
/// }
/// @endcode
/// Please @b note, that COMMS library doesn't impose any restrictions on
/// how the input data is collected and stored. It is a responsibility of the 
/// @b caller to allocate and maintain the input buffer, while providing only an 
/// iterator for read operation. @n
/// Also @b note, that iterator is passed by reference, which allows advancing 
/// operator when read operation is performed. @n
/// For example:
/// @code
/// std::size_t readMessage(MyMessage& msg, const std::uint8_t* buf, std::size_t len)
/// {
///     MyMessage::ReadIterator readIter = buf;
///     auto es = msg->read(readIter, len); // readIter is advanced in the read operation
///     if (es != comms::ErrorStatus::Success) {
///         ... // Report and handle error
///         return 0U; 
///     }
///     
///     // Report number of processed bytes from buffer:
///     auto bytesCount = std::distance(MyMessage::ReadIterator(buf), readIter);
///     return bytesCount;
/// }
/// @endcode
///
/// @subsection page_message_tutorial_interface_write Polymorphic Write of Payload (Serialisation)
/// If the implementation requires polymorhpic serialisation of the messages and sending them over I/O
/// link, the @b write() operation needs to be added to the interface. It is 
/// achieved by using  comms::option::WriteIterator option to provide a type of 
/// the iterator that is going to be used for writing:
/// @code
/// typedef comms::Message<
///     ...
///     comms::option::WriteIterator<std::back_insert_iterator<std::vector<std::uint8_t> > >,
///     ...
/// > MyMessage;
/// @endcode
/// As the result the interface class defines the following types and functions:
/// @code
/// class MyMessage
/// {
/// public:
///     // Type of the the iterator used for writing, the same as provided with
///     // comms::option::WriteIterator option.
///     typedef ... WriteIterator;
///
///     // API function to perform write
///     comms::ErrorStatus write(WriteIterator& iter, std::size_t len)
///     {
///         return writeImpl(iter, len);
///     }
///
/// protected:
///     // May be overriden in the derived class.
///     virtual comms::ErrorStatus writeImpl(WriteIterator& iter, std::size_t len)
///     {
///         return comms::ErrorStatus::NotSupported;
///     }
/// }
/// @endcode
/// Please @b note, that COMMS library doesn't impose any restrictions on
/// storage type for the output buffer. It is a responsibility of the 
/// @b caller to allocate and maintain the output buffer, while providing only an 
/// iterator for write operation. In the example above the output buffer
/// is chosen to be @b std::vector<std::uint8_t> and the write operation will
/// be performed using @b push_back() calls on this vector (due to @b std::back_insert_iterator
/// being chosen as @b WriteIterator). @n
/// Also @b note, that iterator is passed by reference, which allows advancing 
/// operator when write operation is performed. 
///
/// @subsection page_message_tutorial_interface_handle Polymorphic Dispatch Message for Handling
/// When new data arrives on I/O link, the <b>Protocol Stack</b>
/// (see @ref mainpage_transport_info) processes
/// the transport information that wraps the message payload, creates the
/// proper message object, based on the message ID information and returns it
/// wrapped in smart pointer (std::unique_ptr) to @b MyMessage
/// interface class. When such pointer is received by outer processing logic, 
/// appropriate  message handling functionality needs to be executed. Using simple
/// switch statement on message ID (returned by @b getId() interface function)
/// can be very @b INEFFICIENT. The COMMS library provides much more efficient way
/// to dispatch messages to appropriate handler. 
///
/// The handler class needs to be forward declared and passed
/// to the definition of @b MyMessage interface via comms::option::Handler option.
/// @code
/// // Forward declaration
/// class MyHandler;
///
/// typedef comms::Message<
///     ...
///     comms::option::Handler<MyHandler>,
///     ...
/// > MyMessage;
/// @endcode
/// When this option is used the @b MyMessage will define the following interface
/// types and functions:
/// @code
/// class MyMessage
/// {
/// public:
///     // The same type as passed via comms::option::Handler option     
///     typedef ... Handler;
///
///     // Dispatch this message to handler
///     void dispatch(Handler& handler)
///     {
///         dispatchImpl(handler);
///     }
///
/// protected:
///     virtual void dispatchImpl(Handler& handler) = 0; // Must be implemented in the derived class
/// };
/// @endcode
/// More details about dispatching will be provided below in @ref 
/// page_message_tutorial_implementation and @ref page_message_tutorial_implementation_handle
/// sections on this page as well as @ref message_handling section of the
/// main tutorial.
///
/// @subsection page_message_tutorial_interface_length Polymorphic Serialisation Length Retrieval
/// Sometimes it may be needed to polymorphically retrieve the serialisation length of the message
/// in order to be able to reserve or allocate enough space for output buffer.
/// The COMMS library provides comms::option::LengthInfoInterface option that
/// adds @b length() member function to the interface defined with comms::Message.
/// @code
/// typedef comms::Message<
///     ...
///     comms::option::LengthInfoInterface,
///     ...
/// > MyMessage;
/// @endcode
/// This option adds the following functions to the interface definition:
/// @code
/// class MyMessage
/// {
/// public:
///     // Retrieve the serialisation length
///     std::size_t length() const
///     {
///         return lengthImpl();
///     }
///
/// protected:
///     virtual std::size_t lengthImpl() const = 0; // Must be implemented in the derived class
/// };
/// @endcode
///
/// @subsection page_message_tutorial_interface_valid Polymorphic Validity Check
/// Sometimes it may be needed to be able to check whether the message contents
/// (fields) have valid values. The COMMS library provides comms::option::ValidCheckInterface
/// option that adds @b valid() member function to the interface:
/// @code
/// typedef comms::Message<
///     ...
///     comms::option::ValidCheckInterface,
///     ...
/// > MyMessage;
/// @endcode
/// This option adds the following functions to the interface definition:
/// @code
/// class MyMessage
/// {
/// public:
///     // Retrieve the serialisation length
///     bool valid() const
///     {
///         return validImpl();
///     }
///
/// protected:
///     virtual bool validImpl() const
///     {
///         return true; // By default all messages are valid, can be overridden in derived class.
///     }
/// };
/// @endcode
///
/// @subsection page_message_tutorial_interface_refresh Keeping Message Contents in a Consistent State
/// Some communication protocol may define fields that depend on other fields.
/// For example, bits in a bitmask field may be used to define whether some
/// optional fields exist. Or the information about amount of elements in 
/// the list to follow may reside in an independent numeric field. @n 
/// After updating such fields directly, using the interface of the message object,
/// the message contents may end up being in an inconsistent (or invalid) state.
/// There must be a way to polymorphically normalise the state of the message object. The
/// COMMS library provides comms::option::RefreshInterface option, that adds
/// @b refresh() member function to the message interface.
/// @code
/// typedef comms::Message<
///     ...
///     comms::option::RefreshInterface,
///     ...
/// > MyMessage;
/// @endcode
/// This option adds the following functions to the interface definition:
/// @code
/// class MyMessage
/// {
/// public:
///     // Refresh message contents
///     bool refresh()
///     {
///         return refreshImpl();
///     }
///
/// protected:
///     virtual bool refreshImpl()
///     {
///         return false;
///     }
/// };
/// @endcode
/// Note, that the @b refresh() member function returns boolean value, which
/// is expected to be @b true in case at least one of the internal fields has
/// been updated, and @b false if message state remains unchanged. @n
/// Also note, that interface provide default implementation of @b refreshImpl()
/// virtual function. The message object that require proper "refresh" functionality
/// may just override it with proper implementation.
///
/// @subsection page_message_tutorial_interface_summary Interface Options Summary
/// All the options introduced above can be used in any order. They can also
/// be repeated multiple times. However, the option that was defined first takes
/// priority over (or overrides) the same option defined later. @n 
/// For example, the definition below defines @b WriteIterator to be
/// <b>std::uint8_t*</b>, because it was defined with first 
/// comms::option::WriteIterator option:
/// @code
/// typedef comms::Message<
///     ...
///     comms::option::WriteIterator<std::uint8_t*>, 
///     ...
///     comms::option::WriteIterator<std::back_insert_iterator<std::vector<std::uint8_t> >,
///     ...
/// > MyMessage;
/// @endcode  
/// The definition below gives a full interface of all
/// the introduced functions: @b getId(), @b read(), @b write(), @b dispatch(),
/// @b length(), @b valid(), and @b refresh().
/// @code
/// typedef comms::Message<
///     comms::option::BigEndian, // Use big endian for serialisation
///     comms::option::MsgIdType<MyMsgId>, // MyMsgId is an enum type defined earlier
///     comms::option::IdInfoInterface, // Add an ability to retrieve message ID value
///     comms::option::ReadIterator<const std::uint8_t*>, // Use const std::uint8_t* as iterator for reading
///     comms::option::WriteIterator<std::uint8_t*>, // Use std::uint8_t* as iterator for writing
///     comms::option::Handler<MyHandler>, // My MyHandler class declared earlier as a handler for messages
///     comms::option::LengthInfoInterface, // Add an ability to retrieve serialisation length
///     comms::option::ValidCheckInterface, // Add an ability to check contents validity
///     comms::option::RefreshInterface  // Add an ability to refresh message contents
/// > MyMessage;
/// @endcode
///
/// @section page_message_tutorial_implementation Implementation
/// Now it's time to implement custom messages defined in some custom protocol.
/// Let's call them @b Message1, @b Message2, @b Message3, ...
/// Let's assume @b Message1 has two integral values. The first one is
/// unsigned value with possible range of [0 - 1000], serialised using 2 bytes, 
/// and the second one is signed with possible range of [-128 - 127], serialised
/// using only 1 byte. Before defining the actual @b Message1 class, these
/// values need to be defined as @b fields (see @ref page_field_tutorial) and
/// bundled into @b std::tuple.
/// @code
/// typedef comms::Field<comms::option::BigEndian> CommonFieldBase;
///
/// typedef std::tuple <
///     comms::field::IntValue<CommonFieldBase, std::uint16_t, comms::option::ValidNumValueRange<0, 1000> >,
///     comms::field::IntValue<CommonFieldBase, std::int8_t>
/// > Message1Fields;
/// @endcode
/// Then, the custom message @b Message1 class needs to be defined as below:
/// @code
/// // TMessage template parameter is expected to be common interface class.
/// template <typename TMessage>
/// class Message1 : public
///     comms::MessageBase<
///         TMessage, // Interface class for all the messages
///         comms::option::StaticNumIdImpl<MyMsgId_Message1>, 
///         comms::option::MsgType<Message1<TMessage> >, 
///         comms::option::FieldsImpl<Message1Fields> 
///     >
/// {
/// public:
///     // Provide names for the fields
///     COMMS_MSG_FIELDS_ACCESS(value1, value2);
/// };
/// @endcode
/// There are several important elements to pay attention to. All of them
/// are described in the following sub-sections.
/// 
/// @subsection page_message_tutorial_impl_interface Providing Interface Class
/// Every custom message class needs to receive the type of the interface
/// class being used, which is passed as the first template parameter to
/// comms::MessageBase. 
/// @code
/// template <typename TMessage>
/// class Message1 : public
///     comms::MessageBase<
///         TMessage, // Interface class for all the messages
///         ...
///     >
/// {
///     ...
/// };
/// @endcode
/// The comms::MessageBase class in turn will publicly inherit
/// from the provided common interface class. As the result the full class inheritance graph may look
/// like this:
/// @diafile message_class_hierarchy.dia
/// @n
///
/// The comms::MessageBase class will provide implementation to the
/// missing virtual functions or override existing ones, only if they where
/// defined in the interface class, i.e. when appropriate options have been used.
/// If some functionality haven't been requested when defining the interface, 
/// the relevant option, provided
/// to the comms::MessageBase won't have any effect.
///
/// @subsection page_message_tutorial_impl_id Providing Static Numeric ID
/// Most binary communication protocols use numeric values for message identification.
/// In this case the known value needs to be provided to comms::MessageBase
/// using comms::option::StaticNumIdImpl option.
/// @code
/// template <typename TMessage>
/// class Message1 : public
///     comms::MessageBase<
///         TMessage, // Interface class for all the messages
///         comms::option::StaticNumIdImpl<MyMsgId_Message1>, 
///         ...
///     >
/// {
///     ...
/// };
/// @endcode
/// When the ID is provided the comms::MessageBase class and the provided interface
/// class defines message ID type (see @ref page_message_tutorial_interface_id_type), 
/// the comms::MessageBase class defines the following non-virtual function:
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// public:
///     typedef TMessage::MsgIdParamType MsgIdParamType;
///
///     static constexpr MsgIdParamType doGetId()
///     {
///         return MyMsgId_Message1;
///     }
/// };
/// } // namespace comms
/// @endcode
/// If message interface class also allowed polymorphic retrieval of the 
/// ID information (see @ref page_message_tutorial_interface_id_retrieve), the
/// comms::MessageBase class also implements required @b getIdImpl() virtual
/// member functions (see comms::MessageBase::getIdImpl()).
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// public:
///     ...
/// protected:
///     virtual MsgIdParamType getIdImpl() const override
///     {
///         return doGetId();
///     }
/// };
/// } // namespace comms
/// @endcode
///
/// @subsection page_message_tutorial_impl_msg_type Providing Actual Message Type
/// In order to automatically provide some of the required functionalities, the
/// comms::MessageBase class needs to be aware of the actual message type that
/// extends it. For this purpose comms::option::MsgType option needs to be
/// used.
/// @code
/// template <typename TMessage>
/// class Message1 : public
///     comms::MessageBase<
///         ...,
///         comms::option::MsgType<Message1<TMessage> >, 
///         ...
///     >
/// {
/// public:
///     ...
/// };
/// @endcode
/// One of the functionalities that require such knowledge is implementation
/// of @b dispatchImpl() virtual function (see @ref page_message_tutorial_interface_handle
/// and comms::MessageBase::dispatchImpl()). The comms::MessageBase class 
/// downcasts its own type to the provided one and invokes appropriate 
/// @b handle() member function from the handling class:
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// public:
///     typedef TMessage::Handler Handler;
///     ...
/// protected:
///     virtual void dispatchImpl(Handler& handler) override
///     {
///         handler.handle(static_cast<Message1<TMessage>&>(*this));
///     }
/// };
/// } // namespace comms
/// @endcode
/// @b NOTE, that @b dispatchImpl() function is created if and only if the
/// type of the handler has been provided to the interface class.
///
/// @subsection page_message_tutorial_impl_fields Providing Message Fields
/// As has it been mentioned earlier, the message payload values need to be
/// defined as @b fields (see @ref page_field_tutorial). The knowledge about
/// message fields can be provided to comms::MessageBase class using
/// comms::option::FieldsImpl option.
/// @code
/// typedef comms::Field<comms::option::BigEndian> CommonFieldBase;
///
/// typedef std::tuple <
///     comms::field::IntValue<CommonFieldBase, std::uint16_t, comms::option::ValidNumValueRange<0, 1000> >,
///     comms::field::IntValue<CommonFieldBase, std::int8_t>
/// > Message1Fields;
///
/// template <typename TMessage>
/// class Message1 : public
///     comms::MessageBase<
///         ...
///         comms::option::FieldsImpl<Message1Fields>
///     >
/// {
///     ...
/// };
/// @endcode
/// @b NOTE, that the fields need to be bundled in @b std::tuple.
///
/// When armed with the knowledge of used fields, the comms::MessageBase class
/// implements a bunch of types and @b non-virtual functions to access and operate 
/// the fields, regardless of the polymorphic interface defined in the 
/// interface class:
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// public:
///     // Redefining the provided std::tuple of fields as internal type
///     typedef ... AllFields;
///     
///     // Access the stored std::tuple of fields
///     AllFields& fields()
///     {
///         return fields_;
///     }
///
///     // Access the stored std::tuple of fields
///     const AllFields& fields() const
///     {
///         return fields_;
///     }
///
///     // Default implementation of read functionality
///     template <typename TIter>
///     comms::ErrorStatus doRead(TIter& iter, std::size_t len)
///     {
///         // Read all the fields one by one
///     }
///
///     // Default implementation of write functionality
///     template <typename TIter>
///     comms::ErrorStatus doWrite(TIter& iter, std::size_t len) const
///     {
///         // Write all the fields one by one
///     }
///
///     // Default implementation of validity check functionality
///     bool doValid() const
///     {
///         // Validate all the fields one by one
///     }
///
///     // Default implementation of length calculation functionality
///     std::size_t doLength() const
///     {
///         // Summarise the reported lengths of all the fields
///     }
///
/// protected:
///     template<std::size_t TIdx, typename TIter > 
///     comms::ErrorStatus readFieldsFrom(TIter& iter, std::size_t len)
///     {
///         // Read fields from and including the specified until the end
///     }
///
///     template<std::size_t TIdx, typename TIter > 
///     comms::ErrorStatus readFieldsUntil(TIter& iter, std::size_t len)
///     {
///         // Read fields from the beginning until (not including) specified
///     }
///
///     template<std::size_t TFromIdx, std::size_t TToIdx, typename TIter > 
///     comms::ErrorStatus readFieldsFromUntil(TIter& iter, std::size_t len)
///     {
///         // Read fields from and including and until (not including) specified.
///     }
///
///     template<std::size_t TIdx, typename TIter > 
///     comms::ErrorStatus writeFieldsFrom(TIter& iter, std::size_t len) const
///     {
///         // Write fields from and including the specified until the end
///     }
///
///     template<std::size_t TIdx, typename TIter > 
///     comms::ErrorStatus writeFieldsUntil(TIter& iter, std::size_t len) const
///     {
///         // Write fields from the beginning until (not including) specified
///     }
///
///     template<std::size_t TFromIdx, std::size_t TToIdx, typename TIter > 
///     comms::ErrorStatus writeFieldsFromUntil(TIter& iter, std::size_t len) const
///     {
///         // Write fields from and including and until (not including) specified.
///     }
///
/// private:
///     AllFields fields_;        
/// };
/// } // namespace comms
/// @endcode
/// However, depending on the options passed to the comms::Message class defining
/// the polymorphic interface, the comms::MessageBase will provide implementation
/// of required virtual functions.
///
/// See also relevant API documentation:
/// @li comms::MessageBase::fields()
/// @li comms::MessageBase::doRead()
/// @li comms::MessageBase::doWrite()
/// @li comms::MessageBase::doLength()
/// @li comms::MessageBase::doValid()
/// @li comms::MessageBase::readFieldsFrom()
/// @li comms::MessageBase::readFieldsUntil()
/// @li comms::MessageBase::readFieldsFromUntil()
/// @li comms::MessageBase::writeFieldsFrom()
/// @li comms::MessageBase::writeFieldsUntil()
/// @li comms::MessageBase::writeFieldsFromUntil()
///
/// @subsubsection page_message_tutorial_impl_fields_read Polymorhic Read Implementation
/// If message interface class allowed polymorphic read (see
/// @ref page_message_tutorial_interface_read), the comms::MessageBase will
/// override @b readImpl() function (see comms::MessageBase::readImpl()).
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// public:
///     typedef TMessage::ReadIterator ReadIterator;
///
/// protected:
///     virtual comms::ErrorStatus readImpl(ReadIterator& iter, std::size_t len) 
///     {
///         return doRead(iter, len);
///     }    
/// };
/// } // namespace comms
/// @endcode
///
/// @subsubsection page_message_tutorial_impl_fields_write Polymorhic Write Implementation
/// If message interface class allowed polymorphic write (see
/// @ref page_message_tutorial_interface_write), the comms::MessageBase will
/// override @b writeImpl() function (see comms::MessageBase::writeImpl()).
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// public:
///     typedef TMessage::WriteIterator WriteIterator;
///
/// protected:
///     virtual comms::ErrorStatus writeImpl(WriteIterator& iter, std::size_t len) const 
///     {
///         return doWrite(iter, len);
///     }    
/// };
/// } // namespace comms
/// @endcode
///
/// @subsubsection page_message_tutorial_impl_fields_length Polymorphic Length Calculation
/// If message interface class allowed polymorphic length calculation (see
/// @ref page_message_tutorial_interface_length), the comms::MessageBase will
/// override @b lengthImpl() function (see comms::MessageBase::lengthImpl()).
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// protected:
///     virtual std::size_t lengthImpl() const 
///     {
///         return doLength();
///     }    
/// };
/// } // namespace comms
/// @endcode
///
/// @subsubsection page_message_tutorial_impl_fields_valid Polymorphic Validity Check
/// If message interface class allowed polymorphic validity check (see
/// @ref page_message_tutorial_interface_valid), the comms::MessageBase will
/// override @b validImpl() function (see comms::MessageBase::validImpl()).
/// @code
/// namespace comms
/// {
/// template <typename TMessage, ...>
/// class MessageBase<Message1<TMessage>, ... > : public TMessage
/// {
/// protected:
///     virtual bool validImpl() const 
///     {
///         return doValid();
///     }    
/// };
/// } // namespace comms
/// @endcode
///
/// @subsection page_message_tutorial_impl_field_names Providing Names to the Fields
/// When preparing message object to send or when handling received message, the
/// fields it contains need to be accessed to set or get their values. The default
/// (build-in) way of achieving that is to get access to the fields tuple 
/// using inherited comms::MessageBase::fields() member function and then using
/// @b std::get() function to access the fields inside the tuple.
/// @code
/// Message1<SomeInterface> msg;
/// auto& allFields = msg.fields();
/// auto& field1 = std::get<0>(allFields);
/// auto& field2 = std::get<1>(allFields);
///
/// field1.value() = 100;
/// field2.value() = 32;
/// sendMessage(msg);
/// @endcode
/// Although it works, it is not very convenient way to access and operate the fields.
/// There is COMMS_MSG_FIELDS_ACCESS() macro that allows to provide meaningful names
/// for the fields:
/// @code
/// template <typename TMessage>
/// class Message1 : public
///     comms::MessageBase<...>
/// {
/// public:
///     // Provide names for the fields
///     COMMS_MSG_FIELDS_ACCESS(value1, value2);
/// };
/// @endcode
/// The said macro creates the following definitions of inner enum @b FieldIdx
/// type as well as @b field_* accessor functions.
/// @code
/// template <typename TMessage>
/// class Message1 : public
///     comms::MessageBase<...>
/// {
/// public:
///     enum FieldIdx
///     {
///         FieldIdx_value1,
///         FieldIdx_value2,
///         FieldIdx_numOfValues
///     }
///
///     auto field_value1() -> decltype(std::get<FieldIdx_value1>(fields()))
///     {
///         return std::get<FieldIdx_value1>(fields());
///     }
///
///     auto field_value1() const -> decltype(std::get<FieldIdx_value1>(fields()))
///     {
///         return std::get<FieldIdx_value1>(fields());
///     }
///
///     auto field_value2() -> decltype(std::get<FieldIdx_value2>(fields()))
///     {
///         return std::get<FieldIdx_value2>(fields());
///     }
///
///     auto field_value2() const -> decltype(std::get<FieldIdx_value2>(fields()))
///     {
///         return std::get<FieldIdx_value2>(fields());
///     }
/// };
/// @endcode
/// As the result, accessing to the fields becomes much easier and clearer:
/// @code
/// Message1<SomeInterface> msg;
/// msg.field_value1().value() = 100;
/// msg.field_value2().value() = 32;
/// sendMessage(msg);
/// @endcode
///
/// @subsection page_message_tutorial_impl_custom_read Custom Read Functionality
/// Sometimes the default implementation of read functionality implemented by
/// comms::MessageBase::doRead() may be incomplete or incorrect and may required
/// additional or different implementation. As an example let's define new message
/// type (@b Message2), which has two fields. The first one is a 1 byte bitmask,
/// the least significant bit of which defines whether the second field exists.
/// The second field is optional 2 byte unsigned integer one.
/// @code
/// typedef std::tuple <
///     comms::field::BitmaskValue<
///         CommonFieldBase, 
///         comms::option::FixedLength<1>,
///         comms::option::BitmaskReservedBits<0xfe, 0> 
///     >,
///     comms::field::Optional<comms::field::IntValue<CommonFieldBase, std::uint16_t> >
/// > Message2Fields;
///
/// template <typename TMessage>
/// class Message2 : public
///     comms::MessageBase<
///         TMessage, 
///         comms::option::StaticNumIdImpl<MyMsgId_Message2>, 
///         comms::option::MsgType<Message2<TMessage> >, 
///         comms::option::FieldsImpl<Message2Fields> 
///     >
/// {
///     typedef comms::MessageBase<
///         TMessage,
///         comms::option::StaticNumIdImpl<MyMsgId_Message2>, 
///         comms::option::MsgType<Message2<TMessage> >, 
///         comms::option::FieldsImpl<Message2Fields> 
///     > Base;
/// public:
///     COMMS_MSG_FIELDS_ACCESS(flags, data);
///     
///     template <typename TIter>
///     comms::ErrorStatus doRead(TIter& iter, std::size_t len)
///     {
///         // Read only the flags value
///         auto es = Base::template readFieldsUntil<FieldIdx_data>(iter, len);
///         if (es != comms::ErrorStatus::Success) {
///             return es;
///         }
///
///         // Update mode (exists/missing) of the optional value to follow
///         if (field_flags.value() != 0) {
///             field_data().setExists();
///         else {
///             field_data().setMissing();
///         }
///     
///         // Read the rest of the fields
///         return Base::template readFieldsFrom<FieldIdx_data>(iter, len - field_flags().length());
///     }
/// };
/// @endcode
/// In order to be able to support custom read functionality, there is a need to
/// @li Use comms::option::MsgType option to specify the actual type of the message,
///     (see @ref page_message_tutorial_impl_msg_type).
/// @li Implement the non-virtual @b doRead() member function with the same
///     signature as provided comms::MessageBase::doRead() with default read
///     functionality implementation.
///
/// When the two conditions above are satisfied, the comms::MessageBase class
/// has inner meta-programming magic to identify the case and invoke the newly
/// provided @b doRead() function from @b readImpl(), when implementing polymorphic
/// read behaviour, instead of default comms::MessageBase::doRead().
///
/// @subsection page_message_tutorial_impl_custom_write Custom Write Functionality
/// On quite rare occasions there may be a need to implement custom write functionality.
/// It can be achieved in the very similar way as @ref page_message_tutorial_impl_custom_read.
/// @li Use comms::option::MsgType option to specify the actual type of the message,
///     (see @ref page_message_tutorial_impl_msg_type).
/// @li Implement the non-virtual @b doWrite() member function with the same
///     signature as provided comms::MessageBase::doWrite() with default write
///     functionality implementation.
///
/// @code
/// template <typename TMessage>
/// class SomeMessage : public comms::MessageBase<...>
/// {
/// public:
///     COMMS_MSG_FIELDS_ACCESS(...);
///     
///     template <typename TIter>
///     comms::ErrorStatus doWrite(TIter& iter, std::size_t len) const
///     {
///         ... 
///     }
/// };
/// @endcode
/// The comms::MessageBase class
/// has inner meta-programming magic to identify the case and invoke the newly
/// provided @b doWrite() function from @b writeImpl() if such is generated.
///
/// @subsection page_message_tutorial_impl_custom_length Custom Length Calculation
/// On quite rare occasions there may be a need to implement custom length calculation functionality.
/// It can be achieved in the very similar way as @ref page_message_tutorial_impl_custom_read.
/// @li Use comms::option::MsgType option to specify the actual type of the message,
///     (see @ref page_message_tutorial_impl_msg_type).
/// @li Implement the non-virtual @b doLength() member function with the same
///     signature as provided comms::MessageBase::doLength().
///
/// @code
/// template <typename TMessage>
/// class SomeMessage : public comms::MessageBase<...>
/// {
/// public:
///     std::size_t doLength() const
///     {
///         ... 
///     }
/// };
/// @endcode
/// The comms::MessageBase class
/// has inner meta-programming magic to identify the case and invoke the newly
/// provided @b doLength() function from @b lengthImpl() if such is generated.
///
/// @subsection page_message_tutorial_impl_custom_valid Custom Validity Check
/// There may be a need to implement custom validity check functionality.
/// It can be achieved in the very similar way as @ref page_message_tutorial_impl_custom_read.
/// @li Use comms::option::MsgType option to specify the actual type of the message,
///     (see @ref page_message_tutorial_impl_msg_type).
/// @li Implement the non-virtual @b doValid() member function with the same
///     signature as provided comms::MessageBase::doValid().
///
/// @code
/// template <typename TMessage>
/// class SomeMessage : public comms::MessageBase<...>
/// {
/// public:
///     bool doValid() const
///     {
///         ... 
///     }
/// };
/// @endcode
/// The comms::MessageBase class
/// has inner meta-programming magic to identify the case and invoke the newly
/// provided @b doValid() function from @b validImpl() if such is generated.
///
/// @subsection page_message_tutorial_impl_custom_refresh Custom Refresh Functionality
/// Let's get back to the definition of @b Message2 mentioned earlier, where
/// the existence of second field (@b data) depends on the value of the least
/// significant bit in the first field (@b flags). During read operation the
/// mode of the @b data is updated after value of the @b flags is read. However,
/// when preparing the same message for write there is a chance that message 
/// contents are going to be put in invalid state:
/// @code
/// Message2<SomeInterface> msg;
/// msg.field_flags().value() = 0x1;
/// msg.field_data().field().value() = 10U;
/// msg.field_data().setMissing(); // Bug, the field should exist
/// sendMessage(msg);
/// @endcode
/// If message is sent, the @b flags will indicate that the @b data field follows,
/// but it won't be serialised, due to being marked as "missing" by mistake. Please note,
/// that all the "write" functions are marked as @b const and are not allowed
/// to update the message fields during write operation. It may be useful to have
/// member function that brings message contents into the valid and consistent
/// state. It should be called @b doRefresh() and return boolean value (@b true
/// in case the message contents were updated, and @b false if they remain
/// intact.
/// @code
/// template <typename TMessage>
/// class Message2 : public comms::MessageBase<...>
/// {
/// public:
///     COMMS_MSG_FIELDS_ACCESS(flags, data);
///     
///     bool doRefresh()
///     {
///         auto expectedDataMode = comms::field::OptionalMode::Missing;
///         if ((field_flags().value() & 0x1) != 0U) {
///             expectedDataMode = comms::field::OptionalMode::Exists;
///         }
///
///         if (field_data().getMode() == expectedDataMode) {
///             // No need to change anything
///             return false;
///         }
///
///         field_data().setMode(expectedDataMode);
///         return true;
///     }
/// };
/// @endcode
/// As the result the code preparing message for sending may look like this:
/// @code
/// Message2<SomeInterface> msg;
/// msg.field_flags().value() = 0x1;
/// msg.field_data().field().value() = 10U;
/// msg.doRefresh(); // Bring message contents into a valid state
/// sendMessage(msg);
/// @endcode
/// If polymorphic refresh functionality is required (see
/// @ref page_message_tutorial_interface_refresh), the actual message class
/// implementation must:
/// @li Implement custom @b doRefresh function as specified above.
/// @li Use comms::option::MsgType option to specify the actual type of the message,
///     (see @ref page_message_tutorial_impl_msg_type).
/// @li Use comms::option::HasDoRefresh option, which will notify comms::MessageBase 
///     about availability of the @b doRefresh function, and allow implementation
///     of @b refreshImpl (see comms::MessageBase::refreshImpl()), if such is
///     required.
///
/// To finalise this section, let's write the final version of @b Message2
/// implementation:
/// @code
/// template <typename TMessage>
/// class Message2 : public
///     comms::MessageBase<
///         TMessage, 
///         comms::option::StaticNumIdImpl<MyMsgId_Message2>, 
///         comms::option::MsgType<Message2<TMessage> >, 
///         comms::option::FieldsImpl<Message2Fields> ,
///         comms::option::HadDoRefresh
///     >
/// {
/// public:
///     COMMS_MSG_FIELDS_ACCESS(flags, data);
///     
///     template <typename TIter>
///     comms::ErrorStatus doRead(TIter& iter, std::size_t len)
///     {
///         ... // see implementation above
///     }
///
///     bool doRefresh()
///     {
///         ... // see implementation above
///     }
/// };
/// @endcode
///

